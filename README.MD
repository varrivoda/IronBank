# 1 Настройка проекта

Для целей доклада нам нужен демо проект, это будет простая модель банка, который выдает кредиты по запросу /get?name=user&amount=999 в рест-контроллере.

Переводом средств занимается сервис TransferMoney с методом transfer(имя адресата, сумма). 

Для успешного перевода кредит должент быть одобрен. В TransferMoney это реализовано с помощью сервиса PredskazService с методом boolean willSurvive(имя адресата), по имени он вычисляет надежность заемщика. В нашей реализации надежность определяется с помощью рандома, кроме случаев когда имя находится в черном списке (у нас он состоит из одного имени "Stark")

Возвращаемся в TransferMoney, если предаказание благосклонно, то метод transfer() возвращает остаток на корр.счете банка, в случае отказа  возвращается -1.

Единственная наша модель это само отделение банка с остатком на счету. Класс Банка помечен @Data и @Entity и имеет метод credit(amount) {totalAmount-=amount;} 

Интерфейс MoneyDao extends JpaRepository<Bank, String>(^почему Стринг,кстати?) параметризован этим Банком. Никакой БД мы не заводили, она проинжектится вконфигах и т.д. (у нас используется H2)

Пройдем по цепочке от Контроллера
ему нужен resultDeposit, который возвр TransferMoneyService.transfer() 

идем в сервис переводов в transfer()
там если хватает остатка на счете банка и сервис предсказаний благосклонен,то вызывается  bank.credit(amount) и moneyDao.save(bank) и возвращается остаток на счете банка. Иначе возвр -1

нехватает БД, у автора сделано чрез flywaydb как-то автоматически, 

todo^ надо разобраться
    
    у него в папке resources/db/mirgation файл  v1_0_Init.SQL:

    CREATE TABLE bank (
	id BIGINT GENERATED BY DEFAULT AS IDENTITY,
	total_amount BIGINT not null
    );

    insert into bank (id, total_amount) values (0, 100500);

А, ну еще добавить application.properties

все равно почему-то не созлается таблица. 
    
    ----было вот чё----
    I actually had (which didn't work):
        src/main/resources/db.migration/
    instead of the correct (which worked):
        src/main/resources/db/migration/
    The db.migration version obviously does not work, but it is hard to spot on the IDE.
    ----а также-----
    I had a different problem, my migration file name was V1_Base_version.sql instead of V1__Base_version.sql. Flyway requires double underscore __ in name prefix.

поправил flyway, но таблица все равно не создавалась
сравнил build.gradle автора, у меня оказалась не прописан Актуатор (? что это)
    
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>



# Часть2, собственно доклад.
Программисты не любят думатьо зависимостях,
откроем пом
у нашего пома есть родитель-спринг-бут
у котокорого есть родитель Спринг-бут-депенденсис
у которгого огромный блок dependencyManagement
при помощи этогоблока указываются версии
иесли мы укажем зависимость без версии,то мавен смотрит в перенте этот блок, где прописаны версии
в этом блоке проприсано около 500 зависимостей,которые согласованы друг с другом

проблема в том,что в нашей компании есть свой parent.pom, как нам быть если мы хотим использовать его.еслимы хотим исподьщлвать Спринг? множественногонаследованиея ведь нет.

Для этоговнашем блоке dependencyManagement можно прописать импорт на так наз "bom"
подробнее см доклад "Maven vs Gradle"

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>io.spring.platform</groupId>
                <artifactId>platform-bom</artifactId>
                <version>Brussels-SR2</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

это сейчас модно,писать свои Бомы, особенно в крупных компаниях

    //в Градле это делается так:
    dependencyManagement {
        imports {
            mavenBom 'org.springframework.cloud:scpring-cloud-dependencies:Daltson.RELEASE'
        }
    }

Теперь непосредственно о зависимостях конкретнонашего приложения:
допустим, нам надо чтобы оно отвечало по http, имело пожддержку БД и JPA
Раньше это было так: "мне надоработать с БД" - и начинается: transactionalManager, SpringTX, Hibernate-entityManager -core  ит.д.. Потом, "нам нужен Спринг" - значит нужет СпрингORM...

Для одной простой strob надо былодумать о 3-5 зависимостях.
Теперь за нас об этом думает Стартер.

Идея стартера такая (кроме всего прочего), что он агрегирует те зависимости, которые нужны длятого "мира",откуда он пришел. Если это Стартер-security, то мы не думаем о том, какие нужны зависимости для security, астартер уже сагрегировал всеэти зависимости. Тоже для data-jpa и всегопрочего. Таким образом,у нас Пом выглядит в 3-5 зависимости - точто нужно, плюс например база данных.

