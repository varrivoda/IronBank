Это конспект доклада Евгения Борисова и Кирилла Толканова про нюансы работы СпрингБута
Доклад записывался в 2017году, на Спринг Буте версии 2.3 или чтото такое. Стех пор кое-что поменялось, но в основном осталось то же самое

По мере освоения материала буду коммитить себе в гитхаб ("IronBank"), но когдамы будем писать своц стартер, придется завести еще  один репозиторий ("IronBank-starter"), дело в том, что нашсобственный стартерэто модуль такого же уровня абстракции, что и основное приложение. А по замыслу, moneyraven это одно из многочисленных приложений банка, но корень гита я сделал именно в нем... Можно конечно сделать парент-пом, лучше не буду на это отвлекаться, а то вместо освоения материала буду 2дня заниматься настройкой проекта. . .

# 1 Настройка проекта

Для целей доклада нам нужен демо проект, это будет простая модель банка, который выдает кредиты по запросу /get?name=user&amount=999 в рест-контроллере.

/*Для целей доклада пишем прототип "железного банка" из "игры престолов" с помощью  спринг-бута. Пишем очень быстро,поэтому ничего лишнего: для демонстрации нам достаточно таблицы bank (id, total_amount), это сводная таблица с отделениями и остатками на счетах. При поднятии приложения создается отделение
insert into bank(..) values (0, 100500)
и это отделение может выдавать кредиты (TransferMoneyService), логика одобрения кредита основана на предсказаниях (PredskazService).*/




Переводом средств занимается сервис TransferMoney с методом transfer(имя адресата, сумма). 

Для успешного перевода кредит должент быть одобрен. В TransferMoney это реализовано с помощью сервиса PredskazService с методом boolean willSurvive(имя адресата), по имени он вычисляет надежность заемщика. В нашей реализации надежность определяется с помощью рандома, кроме случаев когда имя находится в черном списке (у нас он состоит из одного имени "Stark")

Возвращаемся в TransferMoney, если предаказание благосклонно, то метод transfer() возвращает остаток на корр.счете банка, в случае отказа  возвращается -1.

Единственная наша модель это само отделение банка с остатком на счету. Класс Банка помечен @Data и @Entity и имеет метод credit(amount) {totalAmount-=amount;} 

Интерфейс MoneyDao extends JpaRepository<Bank, String>(^почему Стринг,кстати?) параметризован этим Банком. Никакой БД мы не заводили, она проинжектится вконфигах и т.д. (у нас используется H2)

Пройдем по цепочке от Контроллера
ему нужен resultDeposit, который возвр TransferMoneyService.transfer() 

идем в сервис переводов в transfer()
там если хватает остатка на счете банка и сервис предсказаний благосклонен,то вызывается  bank.credit(amount) и moneyDao.save(bank) и возвращается остаток на счете банка. Иначе возвр -1

нехватает БД, у автора сделано чрез flywaydb как-то автоматически, 

todo^ надо разобраться
    
    у него в папке resources/db/mirgation файл  v1_0_Init.SQL:

    CREATE TABLE bank (
	id BIGINT GENERATED BY DEFAULT AS IDENTITY,
	total_amount BIGINT not null
    );

    insert into bank (id, total_amount) values (0, 100500);

А, ну еще добавить application.properties

все равно почему-то не созлается таблица. 
    
    ----было вот чё----
    I actually had (which didn't work):
        src/main/resources/db.migration/
    instead of the correct (which worked):
        src/main/resources/db/migration/
    The db.migration version obviously does not work, but it is hard to spot on the IDE.
    ----а также-----
    I had a different problem, my migration file name was V1_Base_version.sql instead of V1__Base_version.sql. Flyway requires double underscore __ in name prefix.

поправил flyway, но таблица все равно не создавалась
сравнил build.gradle автора, у меня оказалась не прописан Актуатор (? что это)
    
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>



# Часть2, собственно доклад.
Программисты не любят думатьо зависимостях,
откроем пом
у нашего пома есть родитель-спринг-бут
у котокорого есть родитель Спринг-бут-депенденсис
у которгого огромный блок dependencyManagement
при помощи этогоблока указываются версии
иесли мы укажем зависимость без версии,то мавен смотрит в перенте этот блок, где прописаны версии
в этом блоке проприсано около 500 зависимостей,которые согласованы друг с другом

проблема в том,что в нашей компании есть свой parent.pom, как нам быть если мы хотим использовать его.еслимы хотим исподьщлвать Спринг? множественногонаследованиея ведь нет.

Для этоговнашем блоке dependencyManagement можно прописать импорт на так наз "bom"
подробнее см доклад "Maven vs Gradle"

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>io.spring.platform</groupId>
                <artifactId>platform-bom</artifactId>
                <version>Brussels-SR2</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

это сейчас модно,писать свои Бомы, особенно в крупных компаниях

    //в Градле это делается так:
    dependencyManagement {
        imports {
            mavenBom 'org.springframework.cloud:scpring-cloud-dependencies:Daltson.RELEASE'
        }
    }

Теперь непосредственно о зависимостях конкретнонашего приложения:
допустим, нам надо чтобы оно отвечало по http, имело пожддержку БД и JPA
Раньше это было так: "мне надоработать с БД" - и начинается: transactionalManager, SpringTX, Hibernate-entityManager -core  ит.д.. Потом, "нам нужен Спринг" - значит нужет СпрингORM...

Для одной простой strob надо былодумать о 3-5 зависимостях.
Теперь за нас об этом думает Стартер.

Идея стартера такая (кроме всего прочего), что он агрегирует те зависимости, которые нужны длятого "мира",откуда он пришел. Если это Стартер-security, то мы не думаем о том, какие нужны зависимости для security, астартер уже сагрегировал всеэти зависимости. Тоже для data-jpa и всегопрочего. Таким образом,у нас Пом выглядит в 3-5 зависимости - точто нужно, плюс например база данных.


# часть 3.
Итак, у нас нет конфликта зависимостей и версий.
Следующая боль - настроить контекст.

Раншье мы прописывали в xml или java-конфигах много инфраструктурных бинов
Например для Hibernate нужен EntityManagertFactoryBean, TransactionManager, DataSource... короче кучач разных инфраструктурных бинов...и что мы раньше делали? создавали в Мейне контекст, если из XML то он был пустой. Еслимы строили из AnnotationConfigApplicationContext, то нам попадались некоторые бины,которые могли настраивать конекст согласно аннотациям....

А в мейне, который у нас сейчас?
SpringApplication.run() а где же здесь контекст? что,спринг отказался от Контекста?

первое - а зачем он нам нужен?
второе - он там есть (метод run() возвражает контекст). Но вообще-то он нам особо и не нужен.

Раньшебыло как? для десктоп-приложений мы писали, например, "new ClassPathXmlApplicationCotext..."
если с Томкатом и webXml, то у нас был ДиспетчерСервлет, который по каким-то конвенциям искал какой-то xml по умолчанию,Юи из него строил Контекст так и иначе.

А теперь у нас только SpringApplication.run()
Он может принимать на вход разные аргументы, например:
1. сапмкласс,вкотором он написан
2. String.class
3. "context.xml"
4. new ClassPathResource("context.xml")
5. Package.getPackage("com.example.boot.ripper")

ответ - можно заставить работать все варианты (и даже String.class, поплясав)
вдокументации написано, что передаем Имя класса, имя Пакета, расположение xml в виде массива Обжектов.

Когда мы сами создавали контекст в Мейне, у нас было много разных классов типа "#$%&ApplicationContext".

А наш спринг-Бутовый не заморачиваетсфя, и делвает только 2 вида контекстов: Web Context и Generic Context, и решает он очень просто: если в classpath есть javax.servlet.Servlet && ConfigurableWebApplicationContext, то делает Веб (AnnotationConfigEmbeddedWebApplicationContext). Иначе - делает AnnotationConfigAnnotationContext.

Передать "старые" типы контекстов мы все-таки можем, но все равно из них построится один из этих двух вариантов.
//таймкод 16:35


# Часть 3.2
И что там в этом контексте-то будет?
Мы не создали ни одного бина, унас только application.run(), на вход он получает тот же класс,помеченный @SpringBootApplication - что же там будет,если в этот контекст заглянуть? (^как заглянуть?) ответ, в нашем случае около 436 бинов. И это мы подключили всего пару стартеров. Микросервисная архитектура,блин! микросервис 180 мБ!
    
    *Как заглянуть в контекст?
    на презентации открыто окно Evaluate expression: run.getBeanDefinitionNames()
    хм, ясчитал что в нынешней версии Idea эта возможность вырезана
    но в run-debugging нашел пункт Evaluate, он неактивен. Делаю Debug-Pause, стал активным, пишу в поле Code frafment: 
            SpringApplication.run(MoneyRavenApplication.class, null).getBeanDefinitionNames();
    Получаю "Cannot evaluate methods after Pause action", а также "Cannot evaluate, current stack frame doesn't support evaluation"...
    Остается только вызвать getBeanDefinbitionNames() в main()...
    Получилось 362 бина. Кто это конкретно?

Откуда взялись все эти бины?
Магия этих стартеров втом, что...
вот мы подключили их 4 шт, и получили поти 400. Подключили бы 10 - получилои бы больше 1000. Потому что каждый стартер, кроме зависимостей, уже приносит какие-то конфигурации,вкоторых прописаны какие-то бины, во например:
Хотим например стартер для Веба. Погнали: DispatcherServlet, InternalResourceIOReolver...
Хотим starter-jpa - в нем EntityManagerFactoryBean и т.д.
Это всепрописано в их конфигурациях,и они приходят сами, без нашего участия.
Мы сегодлня сделаем точно также, то есть мы напишем стартер, который точно также будет приносить какие-то бины во все приложения, которые этим стартером будут пользоваться.


# Часть 4. Пример
у Железного банка много разных приложений в разных филиалах, но они хотят, чтобы каждый раз, когда поднимается приложение, посылался ворон с информацией о том, что приложение поднялось.

То есть, нам не надо писать код в приложение конкретного банка, а мы будем писать стартер, чтобы все приложения Iron банка, которые используют этот стартер, посылали ворона при их поднятии.

Делаем новый Модуль iron-starter? структура каталогов src/java/main
Напишем новй класс,который будетпосылать ворона. Пусть это будет Listener, который слушает контекст,икогдаон рефрешнудся,значит надо посылать.
implements ApplicationListener<ContextRefreshedEvent>

Листенер это круто, но его неплохо все же прописать в какой-то конфигурации. Можно конечно @ComponentScan поставить, но для нашей задачи не подходит,т к это чужасконфигурация, конфигурация стартера. Сегоднядекларирует Листенер,завтра заказчик попросит что-нибудь другое, мы тожепропишем их в конфигурации этогшостартера.

Делаем класс IronConfiguration под аннотацией @Configuration
в нем @Bean RavenListener(){return new RavenListener();}

Вопрос, а как сделать, чтобы эта конфигурация автоматически подтянулась во все приложения? В СпрингБуте мы видели штуки типа @EnableSomeStarter на все случаи жизни. Допустим, мы зависим от 20стартеров,и у нас стоят @EnableFirstStarter, @EnableSecondStarter и т.д.?vs что тдолжны ими обвешаться, как ёлка! давайте еще сделаем @import(SomeStarterConfig.class).. Нет! мы хотим сделать некую инверсию контроля, мы хотим подключая стартер иничего не знать о том, как называются его внутренности, но чтобы все работало.

Поэтому мыбудем использовать spring.factories. Что это такое?
В документации написано, что есть такой волшебный файл META-INF/spring.factories, в которм указано cответствие интерфейсов, и того, что надо по ним подгрузить (наши конфигурации). И после чего они волшебным образом появятся в нашем контексте.

Таким образом мы получаем инверсию контроля. То есть тот, кто подключил стартер, вместо того, чтобы обращаться к "кишкам" и выбирать, какую взять конфигурацию, все будет наоборот. У стартера будет файл,и в нем будет прописано,какая конфигурация дложна быть активизирована у всех тех, кто его подгрузил.

создаем resources/META-INF/spring.factories
в нем пишем

    org.springfrmework.boot.autoconfigure.EnableAutoConfiguration=IronConfiguration

В какой-то момент СпрингБут начинает сканировать все jar'ы, и начинает искать вот этот файл spring.factories, мы это потом разберем подробнее, но пока подключим так.

теперь надо подключить, в Градле это выглядит как compile project(':iron-starter'), в Мавене надо поставить в депенденси.

Запускаем...

Тут говорят,что начиная со СпрингБут 3.0 spring.factories больше не поддерживается

    ***    
    I spent literally days on a similar issue and this is what worked for me. If you're using Spring boot 3+ they changed all this! You can find the change documented in the 2.7 release notes here: 2.7 release notes#auto-configuration. In release 2.7 they supported both the old and new ways for backwards compatibility and marked spring.factories as deprecated (deprecation notice). They removed support completely in 3.0! You can find the removal information in the 2.7 -> 3.0 migration guide here: 
    
        https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide#auto-configuration-files. 
    
    In essence, you're now required to annotate your top level auto-configuration class with @AutoConfiguration and add the fully qualified name to a file in this location:

        "META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports"; 
    
    yes this is the name of the file. The different auto-configuration classes will be separated by newlines instead of a comma-separated string like in spring.factories.
    ***

Короче, сделал как в руководстве https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide#auto-configuration-files, 
и ворон полетел.

Причем мы для этого ничего не делали в нашем приложении.
С точки зрения пользователя мы просто подключили зависимость, и у нас появилась конфигурация и появился новый функцилонал.

    (в другом видео про СпринргБут вроде бы говорилось,что исплользовать Листенер не очень правильно, todo разорбраться)

# Часть 5. Как это  работает?
//В связи с устареванием spring.factories этот раздел может быть не актуален

Это  работает благодаря аннотации @SpringBootApplication? это
аннротация мощная, которая за собой несет кучу всего
ив первую очередьона несет @EnableAutoConfigurtion
...который несет всебе тот самый импорт

вспомним.какмыстроили контекст руками через new AnnotationConfig ////
() и передавали на вход конфигурацию,которая была java-классом. Сейчас мы тоже пишем application.run(), в который передаем какой-то класс,который явл конфигурацией,тольк он не помечен аанотвйцией @Configuration, а он помечен @SpringBootApplication. Но ели разобраться, что такое SpringBootApplication, то востоит внутри @configuration 
то есть наш главный класс это еще и конфигурация,там можно прописывать бины

Во-вторых там стоит еще и @ComponentScan, который сканирует все пакеты и подпакеты. Соответственно если мы пишем сервисы или контроллеры в наше пакете,то они автоматически просканируются.

И кроме этого там есть этот сммыйц @EnableAutoConfiguration
(вообще SpringBootAppllication не делает ничегонового, он просто делает все то,что раньшеделали хорошие приложения,ниписанные на спринге, благодаря тому что это теперькомпоиция аннотаций,в т.ч @ComponentScan) 

Вернемся в EnableAutoConfoiguration. Именно этот класс мы прописывали в spring.factories
А его главная задача это сделать вот такой @Import({EnableAutoConfogurationImportSelector}) 
Именно от него мы хотели избавиться в нашем приложении, чтобы получить инверсию контроля, чтобы в приложении не писать название класса, который хотим подключить (чтобы не читать документацию :)

Этот класс заканчивается на "..ImportSelector". Это не обычная конфигурация, которую мы обычно импортируем через аннотыцию @Import 
Вообще с помощью этой аннотации можно импортировать 3 типа - Конфигурацию, ИмпортСелектор и ...еще что-то не сильно важное

ююИэтот ImportSelector протаскивает все наши стартеры (а в итоге весь наш контекст)

Для этого он использует SpringFactoriesLoader, который ищет всякие штуки по всем jar'ам

Каждый стартер несет всякие штуки,и у каждогостартера есть свой spring.factories при помощи которогокоторогоони рассказывают,чтоу нихесть.А у Спринг бута есть механизм, который из всех стартеров приосит то,что они рассказывают в этих spring.factories

Но есть нюанс: у самого Спринг-бута есть его личный jar с его личным spring.factories, в котором есть точно такая же строчка с EnableAutoConfiguration=\, и в ней уже прописаны очень много разных конфигураций. Итого это около 80 автоконфигураций, не связанных друг с другом. И это независимо от того,подключали мы чтото сами или нет.
Более того,каждая эта автоконфигурация может содердать в себе множество другихконфигурация,как например кэш автоконфигураций spring-boot-autoconfigure.jar  
    @Import(CacheConfigurationImportSelector.class)
    public class CacheAutoConfiguration{
        ...
        for (int i=0; i<types.length; i++){
            imports[i] = CacheConfigurations.getConfigurationClass(types[i]);
        }
        return imports;
        
более того, далее он берет это  класс, статически вынимает изнего какуюто мапу, и в этой мапе захардкожены еще другие конфигурации, которых нет в spring.factories 
Найти их не так просто, ипри этом они все будут пытаться загрузиться, причем там есть какие-то reddis,hazzlecast и прочие устаревшие не испольхующиеся штуки...

Бороться с этим нам поможет фильтр - аннотация @Conditional

..Итак, повторим с начала,подведем итоги концепцуии
Часть конфигураций - те,которые хорошие и соблюдают O/C принцип - они несут свои spring.factories, и мысвой стартер пишем также, да и не можем по другому.

кроме этого часть конфинураций прописанывсамом сринг-бвуте (около 80-90шт) 
Кроме этого штук 30захардкожены в коде спрингбута
    
...и вот всеэто поднимается, и потом уже начинают фильтроваться

См лекцию Борисова "что нового в Спринге 4" за 2013год.
Ранее в Спринге 3 была аннотация @Profile c помощью которой мыне хотим чтобы некоторые бины всегда создавались. А @Conditional это еще более мощный механихм, который оченьактивно используется в СпрингБуте, который дает возможность писать свои аннотации - @Conditions которые ссылаются на какие-то классы, которые возщвращают true/false, и в зависимости от этого бин либо создается, либо нет (см ниже)

А поскольку java-конфигурация в Спринге тоже является бином,то там тоде можноставить всыкие @Conditionalы, и если они векрнуди false, то эти конфигурации считались, но после этого отбросились. Так и работает этот фильтр.


# ЧАСТЬ 6
Но есть нюансы, например что бин может быть или не быть, в зависимости от настроек окружения.
Разберем как роз такой  пример: Заказчик просит, чтобы Ворона нужно было запускать только на продакшене. То есть,Листенер недолджен создаваться всегда, а только если у нас продакшен.

Идем в нашу конфигурацию, пишем свою аннотацию @ConditionOnProduction
Создаем новую, задаем ретеншн рантайм, затем над @интерфейсом пишем @Conditional(OnProductionCondition.class), создлаем этот класс в подпакете annotation

этот класс implements Condition {
    оверрайдим matches(принимает Контекст и AnnotatedTypeMetadata){
        return JOptionPane.showConfirmDialog(null, "это продакшен?") == 0;   
    }
}

Кстати, вот так делается "стары-добрый" Попап.
Правда сначала выскакивал java.awt.HeadlessException, немного погуглив нашел решение  

    You can also just pass the a JVM parameter when running your application, no code change required:

        -Djava.awt.headless=false

Все работает, запускаем - всплывает диалог, если нажали "yes", то ворон полетел, если "No" то нет.

# Часть 7
Вот допустим,теперь у на есть 10 бинов, и на всех них мы поставим @ConditionOnProduction
Вопрос: сколько раз отработает логика, которая опредяляет, продакшен у нас или  нет?
Допустим, она дорогая или долгая...

Представи,что унас есть 2 бина 

    @Configuration
    @ConditionalOnSevereWinter
    public class UndeadArmyConfiguration{
        ...
    }

и второй

    @Configuration
    public class DragonIslandConfiguration{
        @Bean
        @ConditionalOnSevereWinter
        public DragonGlassFactory dragonGlassFactory(){
            return new DragonGlassFactory();
        }
    ...
    }


вопрос:сколько обращений за прогнозом погоды будет, если

Варианты:
- если результат обращения кешируется, то один раз
- кешироваться не должен,потому что вдруг за время,пока создается второй бин, погодные условия уже изменились, тогда кондишен будет разный.. ответ - 2раза
- 3или 4 раза
- 6-10 раз
- больше 10раз
итак,правильный ответ 3 или  4 раза.
- Если @conditional стоит над классом (первый бин из примера) то отрабатывает 3раза о_0
Но если эта конфигурация прописана в стартере,то 2 раза

- А если этот бин прописан внутри конфигурации (бин №2 в примере) - то всегда 1 раз.

Поэтому в нашем примере надо знать,прописана ли аннотация в стартере, если да, то 2+1, если нет то 3+1

Почему так получается? Мы не будет здесь касаться этого вопроса, это слишком сложно.

ВЫВОД:
Когда мы пишем свою кондишен-анноитацию,нверно надо самим делать в ней кеширование,чтоьбы логика не вызывалась много раз. . .

# ЧАСТЬ 8. Настройка стартера?
Вообще,стартеры приносят конфигурацию, в которой есть куча бинов, и возникает вопрос - а как они настроены? Вот например data source - какой там логин и пароль к БД? Для этого унихесть дефолты на всеслучаи жизни: не сказали какой логин, ну значит root... Но у нас есть возможность это все переопределять, например в том же applicqation.properties или application.yml (которая еще и автокомплитится), вот все это можно рассказать стартеру, и наш стартер не исключение, мы будет точно такжепробовать его настроить.

Конкретно мы будем настраивать три вещи: 
1)чтобы где-то был прописан список получателей (applicqation.properties или .iml)
2)чтобы ворон не создавался, если список получателей пуст (дополнительные кондишены на соз
лание листенера, посылающего ворона. Т к в стартереможет быть еще многодругих полезных вещей, кроме ворона)
3) хочется, чтобы у того, кто наш стартер подтянул, был автокомплит на все проперти, которые считывает наш стартер.

Кроме того что мы можемписать свои реализации @Conditional существует множество уже написанных кондишенолов на разные случаи жизни. Посмотрим на них повнимательнее,может кто-то нам пригодится без переделок?

@ConditionalOnBean
@ConditionalOnClass
@ConditionalOnCloudPlatform
@ConditionalOnExpression
@ConditionalOnJava
@ConditionalOnJndi
@ConditionalOnMissingBean
@ConditionalOnMissingClass
@ConditionalOnNotWebApplication
@ConditionalOnProperty
@ConditionalOnResource
@ConditionalOnSingleCandidate
@ConditionalOnWebApplication
    ... и другие.

задачу со списком получателей мы сможем решить, поместив его в проперти-файл или yml.
задачу создания ворона только при наличии списка - @ConditionalOnProperty (проперти из п.1)
задачу автокомплита поможет @ConfigurationProperties, а вот это что такое? С него и начнём.

Откуда береься автокомплит? Есть JSON файл, в котором описаны все проперти,которые Идея должна уметь автокомплитить. Если мы хотим автокомплитить свои проперти, есть 2 варианта:
добавить их вручную в этот JSON, и второй вариант - использовать специальный СпрингБутовый аннотейшнПроцессор, который умеет генерить этот JSON на этапе компиляции. А узнать о том, что конкретно надо добавлять, ему поможет аннотация СпрингБута @ConfigurationProperty, которой мы можем маркировать классы-прперти-холдеры, и на этапе компиляции процессор этой аннотации СпрингБута найдет все классы,помеченные этой аннотацией, считает все эти проперти и сгененит это JSON, затем все кто зависит от нашего стартера,получат это JSON, после чегоИдея сагрегирует все эти JSON'ы, и заработает автокомплит.

пишем этот класс-проперти-холдер RavenProperties помеченный аннотацией @ConfigurationhProperty("ворон")
public class RavenProperties{
    List<String> куда;    
}

для работы этой аннотации надо добавить зависимость
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-configuration-processor</artifactId>
        <version>3.1.2<version>
        <optional>true</optional>
    </dependency>

т к у нас нет парента, то без версии работать не будет

Также,теперь когда депенденси загрузилась, при наведении на @ConfigurationProperties всплывает ошибка "Not registered via @EnableConfigurationProperties, marked as Spring component, or scanned via @ConfigurationPropertiesScan". Исправим это, поставив аннотацию @EnableConfigurationProperties(RavenProperties.class) над конфигурацией

Еще, по непонятной причине была циклическая зависимость в pom, устранил. 
Все заработало, автокомплит есть. Причем как в yml, и application.properties





