# 1 Настройка проекта

Для целей доклада нам нужен демо проект, это будет простая модель банка, который выдает кредиты по запросу /get?name=user&amount=999 в рест-контроллере.

Переводом средств занимается сервис TransferMoney с методом transfer(имя адресата, сумма). 

Для успешного перевода кредит должент быть одобрен. В TransferMoney это реализовано с помощью сервиса PredskazService с методом boolean willSurvive(имя адресата), по имени он вычисляет надежность заемщика. В нашей реализации надежность определяется с помощью рандома, кроме случаев когда имя находится в черном списке (у нас он состоит из одного имени "Stark")

Возвращаемся в TransferMoney, если предаказание благосклонно, то метод transfer() возвращает остаток на корр.счете банка, в случае отказа  возвращается -1.

Единственная наша модель это само отделение банка с остатком на счету. Класс Банка помечен @Data и @Entity и имеет метод credit(amount) {totalAmount-=amount;} 

Интерфейс MoneyDao extends JpaRepository<Bank, String>(^почему Стринг,кстати?) параметризован этим Банком. Никакой БД мы не заводили, она проинжектится вконфигах и т.д. (у нас используется H2)

Пройдем по цепочке от Контроллера
ему нужен resultDeposit, который возвр TransferMoneyService.transfer() 

идем в сервис переводов в transfer()
там если хватает остатка на счете банка и сервис предсказаний благосклонен,то вызывается  bank.credit(amount) и moneyDao.save(bank) и возвращается остаток на счете банка. Иначе возвр -1

нехватает БД, у автора сделано чрез flywaydb как-то автоматически, 

todo^ надо разобраться
    
    у него в папке resources/db/mirgation файл  v1_0_Init.SQL:

    CREATE TABLE bank (
	id BIGINT GENERATED BY DEFAULT AS IDENTITY,
	total_amount BIGINT not null
    );

    insert into bank (id, total_amount) values (0, 100500);

А, ну еще добавить application.properties

все равно почему-то не созлается таблица. 
    
    ----было вот чё----
    I actually had (which didn't work):
        src/main/resources/db.migration/
    instead of the correct (which worked):
        src/main/resources/db/migration/
    The db.migration version obviously does not work, but it is hard to spot on the IDE.
    ----а также-----
    I had a different problem, my migration file name was V1_Base_version.sql instead of V1__Base_version.sql. Flyway requires double underscore __ in name prefix.

поправил flyway, но таблица все равно не создавалась
сравнил build.gradle автора, у меня оказалась не прописан Актуатор (? что это)
    
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>



# Часть2, собственно доклад.
Программисты не любят думатьо зависимостях,
откроем пом
у нашего пома есть родитель-спринг-бут
у котокорого есть родитель Спринг-бут-депенденсис
у которгого огромный блок dependencyManagement
при помощи этогоблока указываются версии
иесли мы укажем зависимость без версии,то мавен смотрит в перенте этот блок, где прописаны версии
в этом блоке проприсано около 500 зависимостей,которые согласованы друг с другом

проблема в том,что в нашей компании есть свой parent.pom, как нам быть если мы хотим использовать его.еслимы хотим исподьщлвать Спринг? множественногонаследованиея ведь нет.

Для этоговнашем блоке dependencyManagement можно прописать импорт на так наз "bom"
подробнее см доклад "Maven vs Gradle"

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>io.spring.platform</groupId>
                <artifactId>platform-bom</artifactId>
                <version>Brussels-SR2</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

это сейчас модно,писать свои Бомы, особенно в крупных компаниях

    //в Градле это делается так:
    dependencyManagement {
        imports {
            mavenBom 'org.springframework.cloud:scpring-cloud-dependencies:Daltson.RELEASE'
        }
    }

Теперь непосредственно о зависимостях конкретнонашего приложения:
допустим, нам надо чтобы оно отвечало по http, имело пожддержку БД и JPA
Раньше это было так: "мне надоработать с БД" - и начинается: transactionalManager, SpringTX, Hibernate-entityManager -core  ит.д.. Потом, "нам нужен Спринг" - значит нужет СпрингORM...

Для одной простой strob надо былодумать о 3-5 зависимостях.
Теперь за нас об этом думает Стартер.

Идея стартера такая (кроме всего прочего), что он агрегирует те зависимости, которые нужны длятого "мира",откуда он пришел. Если это Стартер-security, то мы не думаем о том, какие нужны зависимости для security, астартер уже сагрегировал всеэти зависимости. Тоже для data-jpa и всегопрочего. Таким образом,у нас Пом выглядит в 3-5 зависимости - точто нужно, плюс например база данных.


# часть 3.
Итак, у нас нет конфликта зависимостей и версий.
Следующая боль - настроить контекст.

Раншье мы прописывали в xml или java-конфигах много инфраструктурных бинов
Например для Hibernate нужен EntityManagertFactoryBean, TransactionManager, DataSource... короче кучач разных инфраструктурных бинов...и что мы раньше делали? создавали в Мейне контекст, если из XML то он был пустой. Еслимы строили из AnnotationConfigApplicationContext, то нам попадались некоторые бины,которые могли настраивать конекст согласно аннотациям....

А в мейне, который у нас сейчас?
SpringApplication.run() а где же здесь контекст? что,спринг отказался от Контекста?

первое - а зачем он нам нужен?
второе - он там есть (метод run() возвражает контекст). Но вообще-то он нам особо и не нужен.

Раньшебыло как? для десктоп-приложений мы писали, например, "new ClassPathXmlApplicationCotext..."
если с Томкатом и webXml, то у нас был ДиспетчерСервлет, который по каким-то конвенциям искал какой-то xml по умолчанию,Юи из него строил Контекст так и иначе.

А теперь у нас только SpringApplication.run()
Он может принимать на вход разные аргументы, например:
1. сапмкласс,вкотором он написан
2. String.class
3. "context.xml"
4. new ClassPathResource("context.xml")
5. Package.getPackage("com.example.boot.ripper")

ответ - можно заставить работать все варианты (и даже String.class, поплясав)
вдокументации написано, что передаем Имя класса, имя Пакета, расположение xml в виде массива Обжектов.

Когда мы сами создавали контекст в Мейне, у нас было много разных классов типа "#$%&ApplicationContext".

А наш спринг-Бутовый не заморачиваетсфя, и делвает только 2 вида контекстов: Web Context и Generic Context, и решает он очень просто: если в classpath есть javax.servlet.Servlet && ConfigurableWebApplicationContext, то делает Веб (AnnotationConfigEmbeddedWebApplicationContext). Иначе - делает AnnotationConfigAnnotationContext.

Передать "старые" типы контекстов мы все-таки можем, но все равно из них построится один из этих двух вариантов.
//таймкод 16:35


# Часть 3.2
И что там в этом контексте-то будет?
Мы не создали ни одного бина, унас только application.run(), на вход он получает тот же класс,помеченный @SpringBootApplication - что же там будет,если в этот контекст заглянуть? ответ, в нашем случае около 436 бинов. И это мы подключили всего пару стартеров. Микросервисная архитектура,блин! микросервис 180 мБ!

Откуда взялись все эти бины?
Магия этих стартеров втом, что...
вот мы подключили их 3 шт,иполучили поти 500. Подключили бы 10 - получилои быюбольше 1000. Потому что каждый стартер, кроме зависимостей, уже приносит какие-то конфигурации,вкоторых прописаны какие-то бины, во например:
Хотим например стартер для Веба. Погнали: DispatcherServlet, InternalResourceIOReolver...
Хотим starter-jpa - в нем EntityManagerFactoryBean и т.д.
Это всепрописано в их конфигурациях,и они приходят сами, без нашего участия.
Мы сегодлня сделаем точно также, то есть мы напишем стартер, который точно также будет приносить какие-то бины во все прилодения, которые этим стартером будут пользоваться.

